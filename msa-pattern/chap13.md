# 13장 마이크로서비스로 리팩터링

모놀리식 지옥에 빠져 있기 때문에 갖가지 문제가 발생하는건 아닌지 진단하고, 리팩토링을 고민해보자

## 모놀리스를 왜 리팩토링 하는가?

* 모놀리식 지옥 문제점
  * 느린 전달: 앱 관리, 테스트가 어려워서 생산성이 떨어지는 문제
  * 버그가 많은 릴리즈: 테스트 부재로 품질이 낮아지는 문제
  * 나쁜 확장성: 확장성이 부족해, 고객의 니즈를 충족하지 못하는 문제

## 모놀리스 옥죄기

마이크로 서비스로 전환할때에는 `완전히 뜯어고치기를 삼가하라`
  - 레거시 서비스 개발을 병행
  - 기존 레거시 기능 대체
  - 신규 기능 추가

일정, 리소스 분산, 리스크를 고려했을 때, 실패할 가능성이 크다.

* 스트랭글러 어플리케이션

네이밍의 중요성: 대략적인 전환방식의 의미를 이해할 수 있음.

스트랭글러 덩굴: 햇볕을 쬐기 위해 나무 주위를 감고 자라고, 나무를 모두 덮어 나무가 죽고, 나무 모양의 덩굴만 남게 된다.

기존 어플리케이션과 함께 실행되면서, 단계적으로 새로운 서비스로 대체하는 방식.

`레거시 애플리케이션`을 새로운 서비스로 단계적으로 대체하는 애플리케이션 현대화 패턴.

* 값을 조기에 검증

워터폴 방식이 아닌, 에자일 방식처럼, 중간, 중간단계에 새로운 서비스의 역할을 검증할 수 있음.

현실적으로, 짧지 않은 기간동안, 지원을 받기 위해서는, 경영진의 도움이 필요하다. 

`향상된 검증 지표를 기반으로 경영진을 설득할 수 있다.`

* 모놀리스 변경 최소화

운영중인 서비스 기능을 대체하는 작업은 위험성이 크기때문에, 변경을 최소화하면서 단계적으로 진행.

* 기술 배포 인프라: 모든것이 다 필요한 것은 아니다.

인프라 개발에 필요한 선행 투자는 최소화하는게 좋다.

반드시 필요한 것은 `테스트 자동화 배포 파이프라인`.

실제 기능을 검증/경험해보기 전까지는 투자를 최소화 하자.

## 모놀리스 -> 마이크로서비스 리팩토링 전략

1. 새 기능을 서비스로 구현한다.
2. 표현 계층과 백엔드를 분리
3. 기능을 여러 서비스로 추출해서, 모놀리스 분해

### 새 기능을 서비스로 구현한다.

`구멍에 빠졌다는 것을 알았으면 땅은 그만 파라`

기존 기능과 연관이 적은 새 기능을 새로운 서비스로 구현해 나간다.

* 새 서비스를 모놀리스에 연계
  * api gateway: 모놀리스와 새 서비스로의 요청을 분리
  * 통합 글루 코드: 서비스 <-> 모놀리스간 연계를 하기 위한 통합 서비스

![Alt text](/images/msa/13-1.png)

### 표현 계층과 백엔드를 분리한다.

mvc: 웹서버와 백엔드 서버를 분리한다.

* 장점
  * 서로 독립적으로 개발,배포, 확장이 가능하다.
  * 마이크로서비스가 호출하는 api가 표출된다.

### 기능을 여러서비스로 추출한다.

모놀리스의 가진 능력을 하나씩 서비스로 옮기는 분해 전략

* 추출해야할 기능
  * api 끝점이 구현된 인바운드 어댑터
  * 도메인 로직
  * db 접근 등 아웃바운드 어댑터
  * db 스키마

가장 가치가 큰 영역부터 집중적으로 리팩토링(리팩토링 비용이 크므로..)

![Alt text](/images/msa/13-2.png)

* 도메인 모델 분리

모놀리스의 객체가 서비스로 이전한 클래스를 참조하는 경우나 그 반대의 경우.
서비스 경계에 있는 도메인 객체 참조를 기본 키로 변경(DDD 애그리거트 관점)

![Alt text](/images/msa/13-3.png)
![Alt text](/images/msa/13-4.png)

* DB 리팩토링

`리팩토링 데이터베이스`: DB 리팩토링하는 전략

데이터를 복제해서 DB 클라이언트가 새 스키마를 사용하도록 단계적인 변화.

* 변경 범위를 줄이기 위해 데이터 복제

도메인 모델을 변경하고, DB 스키마를 분리하는 방식은 큰 변경범위를 불러올 수 있다.

`리팩토링 데이터베이스`의 전략에 의하면, 전이 기간동안에는 원본 스키마를 유지하되, 원본과 신규 스키마를 동기화하는 방식.

분리할 영역의 데이터는 `읽기전용`으로 만들고, 데이터를 쓰는 부분을 서비스로 이전

![Alt text](/images/msa/13-5.png)

* 어떤 서비스를 언제 추출하나

혜택이 큰 서비스부터 추출(비용 문제, 경영진에게 빠른 피드백)

* 서비스 추출하는 순서를 정하는 전략
  * 요건이 있을때 마다 서비스로 추출: 모놀리스를 분해하게 만드는 장점, 그러나 사소한 변경이 서비스 추출이라는 비효율적인 측면도 존재.
  * 서비스 추출 시 기대되는 혜택으로 정렬
    * 개발 가속화: 개발 분량이 많은 부분의 경우, 복잡성을 낮춰 개발 속도를 향상시킬 수 있다.
    * 성능, 확장성, 신뢰성 문제 해결: 기존에 확장이나, 신뢰성에 문제가 있던 부분은 추출할 가치가 있다.
    * 다른 서비스로 추출할 수 있게 만듦: 한 서비스를 추출함으로써, 다른 서비스의 추출도 단순해지는 경우(전체적인 복잡성 완화)

## 서비스와 모놀리스 간 협동 설계

모놀리스에서 서비스로 분리될때, 원래 ACID 트랜잭션에 묶여 있던 코드도 분리되기 때문에, `데이터 일관성`을 맞춰줘야 한다.

### 통합 글루 설계

특정 `IPC`를 이용하는 코드를 서비스 및 모놀리스 양쪽에 구성

```java
interface ContactInfoRepository {
    ContactInfo findContactInfo(String id);
}

interface DeliveryService{
    void schedule();
    void reschedule();
    void cancel();
}
```

* 상호 작용 스타일과 IPC 선택

사용 빈도, 데이터 크기를 고려해서 연계 방식을 선택해야 한다.(예: rest, 레플리카)

![Alt text](/images/msa/13-6.png)

* 부패-방지 계층 구현

서로 다른 도메인 모델을 연계할 때, 각 서비스에 맞는 형태로 변환해주는 계층

* 예: 모놀리스의 고객정보 api를 호출한 뒤, `ContactInfo`형식으로 맞게 변환

* 모놀리스가 도메인 이벤트를 발행/구독하는 방법

데이터 변경하는 모든 지점에 이벤트를 발행하는 코드를 추가하기란 어려운 일이다.

어플리케이션의 변경이 어렵다면, DB 수준에서 도메인 이벤트를 발행하는 방법이 있다. 

하지만, 테이블 변경사항을 나타내는 수준의 이벤트만 발생할 수 있게된다.

이벤트 수신은 이벤트 프레임워크의 핸들러를 이용하면 비교적 쉽게 이벤트를 구독할 수 있으나,

지원하지 않는 언어일 경우엔, 별도의 어플리케이션을 작성해 모놀리스 DB를 업데이트 하는 방법도 고려해보자

### 서비스와 모놀리스에 걸쳐 데이터 일관성 유지

데이터 일관성을 위해, 사가를 도입하는 방법이 있지만, 모놀리스에 사가를 적용하기 어려운 경우에는

모놀리스에 있는 트랜잭션이 피봇, 재시도 가능 트랜잭션이 되도록, 서비스 추출 순서를 조절해볼 수 있다.

* 보상 트랜잭션을 지원하도록 모놀리스를 고치기는 어렵다.

주문을 생성하는 첫번째 트랜잭션을 보상 트랜잭션으로 만들기 위해서, APPROVAL_PENDING이라는 상태를 Order 엔티티에 추가하기가 쉽지 않다.

테스트 하기 어려운 부분도 많아 위험성이 크다.

```
1. 주문 내역을 확인
2. 주문 가능한 소비자인지 확인
3. 소비자 신용카드를 승인
4. 주문 생성

---

1. 모놀리스
  - 주문을 APPROVAL_PENDING 상태로 생성
  - 주문 가능한 소비자인지 확인
2. 주방 서비스
  - 주문 내역 확인
  - 티켓을 CREATE_PENDING 상태로 생성
...
```

* 사가 적용 시 모놀리스는 보상 트랜잭션을 지원할 필요가 없다.

서비스마다 사가가 다르기 때문에, 서비스 추출 시, 모놀리스에 보상 트랜잭션을 구현할 필요가 없는 사가로 설계하는것도 가능하다.
```
1. 주문 서비스
  - 주문을 APPROVAL_PENDING 상태로 생성
2. 모놀리스
  - 주문 가능한 소비자인지 확인
  - 주문 내역을 확인 후 티켓 생성
  - 신용카드 승인
3. 주문 서비스
  - 주문 상태를 APPROVED로 변경
```

위 예제에서는 모놀리스의 트랜잭션은 `피봇 트랜잭션`이기 때문에, 보상 트랜잭션을 지원할 필요가 없어진다.

* 서비스 추출 순서를 조정하면 보상 트랜잭션을 모놀리스에 구현하지 않아도 된다.

위 예제에서 봤듯이, `주방 서비스`를 추출하려면 보상 트랜잭션 지원이 필요하지만, `주문 서비스`는 필요 없었다.

이 처럼 서비스 추출 순서를 조절하면, 모놀리스를 광범위하게 수정하는 리스크를 피할 수도 있다.

### 인증/인가 처리

마이크로 서비스로의 전환을 위해서, 인-메모리 세션기반의 인증방식과 토큰 형식의 인증방식을 동시에 지원해야 합니다.

![Alt text](/images/msa/13-7.png)

## 새 기능을 서비스로 구현: 배달 실패한 주문 처리

상황: 배달되지 않은 주문에 대한 고객 불만이 증가로 `실패한 배달 처리 프로세스 개선`이 필요한 상황

원인은 배달 알고리즘이었고, 개선중이나 언제 완료될지 미지수인 상태일 경우.

```
구현해야할 새 기능

1. 주문이 제시간에 배달되지 못할 경우 고객에게 알림
2. 음식점 영업 종료 전에 주문 픽업이 불가능할 경우, 고객에게 알림
3. 주문이 제시간에 배달이 불가능할 경우, 고객 서비스 센터를 통해 보상책 제시
4. 배달 통계 추적
```

### 배달지연 서비스 설계

`getDelayOrders()`를 통해, 지연되는 배달이나, 배달 불가능한 주문을 조회하는 기능 제공.

api-gateway를 통해서 `getDelayOrders`요청만 배달지연 서비스로 라우팅

![Alt text](/images/msa/13-8.png)

### 배달 지연 서비스를 위한 통합 글루 설계

Order, Restaurant 엔티티를 소유하지 않고, 복제한다.

ContactInfo는 직접 조회한다.

![Alt text](/images/msa/13-9.png)

## 모놀리스 분해: 배달 관리 추출

배달 관리 기능을 개선한다고 할때, 모놀리스의 문제는 배달 관리와, 주문 관리가 서로 뒤엉켜 있다는 점이다.

### 현행 배달 관리 기능

```
// 모놀리스에서 배달관리에 요청하는 커맨드 
acceptOrder: 주문 접수, 배달 스케줄 생성
cancelOrder: 소비자의 주문 취소, 필요하다면 배달 취소
noteCourierLocationUpdated: 배달원의 위치를 업데이트, 배달 스케줄 재조정
noteCourierAvailabilityChanged: 배달원의 가용성 업데이트, 배달 스케줄 재조정

// 배달 관리에 필요한 데이터 조회 쿼리
getCourierPlan: 배달원의 계획 반환
getOrderstatus: 배달 관련정보 및 주문 상태 반환
getOrderHistory: 다수의 주문 상태를 반환
```

![Alt text](/images/msa/13-10.png)

### 배달 서비스 개요

서비스 도메인 모델을 결정하려면 아래의 답을 해야한다.

* 어떤 동작과 데이터를 배달 서비스로 이전할지?
* 배달 서비스는 어떤 api를 제공할지?
* 모놀리스는 어떤 api를 제공할지?

### 배달 서비스의 도메인 모델 설계

* 배달 관리를 구성할 엔티티/필드 식별

배달 스케줄링 알고리즘은 모놀리스의 여러 값들을 읽어, plan, scheduledPickupTime, scheduledDeliveryTime을 업데이트 한다.

![Alt text](/images/msa/13-11.png)

* 배달 서비스로 이전할 데이터 결정

어떤 엔티티와 필드가 배달 관리에 참여하는지 식별했다면, 어떤 부분을 이전할지 결정해야 한다.

그러나 모놀리스는 많은 영역에서 해당 값들을 공유하고 있기 때문에, 서비스 <-> 모놀리스에 분산된 데이터를 연계하는 방법과,

일관성을 유지하는 방법을 고민해야한다.

> 배달 서비스의 주 임무는 scheduledPickupTime, scheduledDeliveryTime을 업데이트이므로, 두 필드를 가져온다.


* 배달 서비스 도메인 로직 설계

모놀리스 기존 비지니스 로직을 대부분 재사용한다. (Order -> Delivery 명칭변경, 사용할 필드만 남기고 제거)

정적 타입 언어일 경우, 컴파일러 도움으로 리팩토링이 수월해진다.

![Alt text](/images/msa/13-12.png)

### 배달 서비스의 통합 글루 설계

* 배달 서비스 api 설계

배달 서비스는 모놀리스가 배달 스케줄을 잡거나, 변경/취소 할 수 있는 api를 제공해야 합니다.

느슨한 결합, 가용성을 늘리기 위해서 `비동기 메세징`방식을 고려할 수도 있습니다.

Order 이벤트를 배달 서비스가 구독하는 방식도 가능합니다. 단. 이 경우, Order 이벤트가 Delivery에 어떤 영향을 미치는지 배달 서비스가 알고 있어야 하는 단점이 있습니다.

따라서 모놀리스가 배달 서비스에 명시적으로 Delivery 생성, 변경, 취소를 지시할 수 있는 알림 기반의 api를 배달 서비스에 구현하는게 좋습니다.

![Alt text](/images/msa/13-13.png)

* 배달 서비스가 모놀리스 데이터에 접근하는 방법

데이터 양이 매우 클 수 있으므로, Courier 도메인 이벤트를 통해 복제하는 방식을 이용합니다.

* 모놀리스가 배달 서비스 데이터를 접근하는 방법

모놀리스가 서비스를 쿼리할 수도 있지만, 모놀리스의 변경점이 커지므로, 필요한 데이터를 이벤트를 통해 복제하는 방식을 이용합니다.

### 배달 서비스와 상호 작용할 수 있게 모놀리스를 변경

신규 배달 서비스와 연계를 하려면 모놀리스도 변경이 필요합니다.

* DeliveryService 인터페이스 정의

배달 메세지 기반의 api를 인터페이스로 정의합니다.

![Alt text](/images/msa/13-14.png)

* DeliveryService 인터페이스를 호출하도록 모놀리스를 리팩토링

이 작업이 모놀리스에서 서비스를 추출하는 가장 어려운 과정이고, 시간이 많이 소요 됩니다.

정적 타입 언어라면 디펜던시를 쉽게 식별할 수 있어서 큰 도움이 됩니다. 그렇지 않다면 변경할 코드를 충분히 검증할 수 있는 테스트 코드가 필요합니다.

![Alt text](/images/msa/13-15.png)

* DeliveryService 인터페이스 구현

배달 서비스에 알림을 보내는 프록시로 교체합니다. 기존 방식과 신규 방식을 동적으로 적용할 수 있도록 설계합니다. 

![Alt text](/images/msa/13-16.png)

이후에 추출하는 서비스는 우선순위를 기반으로 결정해나갑니다. 서비스가 추출될 수록, 복잡성은 낮아지고, 유지보수성과 테스트성은 향상될 것으로 기대할 수 있습니다.

## 마치며
* 모놀리식 아키텍쳐로 인해 소프트웨어 문제가 발생하는지 점검이 필요합니다.
* 스트랭글러 애플리케이션을 개발해, 단계적으로 모놀리스 기능을 대체하는게 좋습니다. 빠른 지표 검증으로 경영진의 설득이 용이합니다.
* 마이크로 서비스를 도입하는 좋은 방법으로 새 기능을 서비스로 구현해서, 적용해보는 것입니다.
* 모놀리스를 표현 계층과 백엔드로 분리하면, 독립적인 설계, 배포가 가능해집니다.
* 모놀리스를 분해하는 주된 방법은, 여러 기능을 단계적으로 전환하는 것입니다. 전환 혜택이 큰 서비스부터 우선 추출합니다.
* 모놀리스 <-> 서비스 연계를 위해서 인/아웃바운드 어밷터로 구성된 통합 글루를 이용합니다.
* 모놀리스 도메인 모델이 서비스 모델을 오염시키지 않게, 부패 방지 계층을 통합 글루에 적용해야 합니다.
* 서비스를 추출할 때, 변경을 최소화하기 위해, 서비스로 이전된 데이터를 모놀리스에 복제합니다.
* 서비스 개발 시, 모놀리스가 개입된 사가를 구현해야하는 경우, 서비스 추출 순서를 잘 조절한다면, 보상 트랜잭션을 지원하지 않도록 변경점을 최소화할 수 있습니다.
* 모놀리스 애플리케이션 인-메모리 세션 기반과 토큰 기반의 인증방식을 동시에 지원해야 합니다. 로그인 핸들러, api-gateway를 이용하면 문제를 해결할 수 있습니다.