## 인상깊었던 부분
#### 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라
- 인터페이스의 인스턴스를 다양한 작업에 활용하는 클라이언트도 여러 개 만들어봐야 한다.

#### 아이템 22. 인터페이스는 타입을 정의하는 용도로만 사용하라
- 상수 공개용 수단으로 사용하지 말자.

#### 아이템 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라
- 태그를 없애고 계층구조로 대체하는 방법을 생각해보자.

#### 아이템 24. 멤버 클래스는 되도록 static으로 만들라
##### 중첩클래스
- 정적 멤버 클래스
  - 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다.
  - 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 쓰인다.
  - 계산기 Calculator -> 연산 Operation Enum 타입
- 비정적 멤버 클래스
  - 바깥 클래스의 인스턴스와 암묵적으로 연결됨
  - 정규화된 this를 사용해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있다 (클래스명.this)
- 익명 클래스
  - 쓰이는 시점에 선언과 동시에 인스턴스가 만들어진다. 코드의 어디서든 만들 수 있다.
  - 오직 비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다.
  - 람다를 지원하기 전에는 즉석에서 작은 함수 객체나 처리 객체를 만드는 데 주로 사용했다.
  - 다른 주 쓰임은 정적 팩터리 메서드를 구현할 때
- 지역 클래스
- 개념상 중첩클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 한다
```
멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들다. static을 생략하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 된다. 이 참조를 저장하려면 시간과 공간이 소비된다. 더 심각한 문제는 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못하는 메모리 누수가 생길 수 있다는 점이다.
```

## 이해가 되지 않았던 부분
#### 아이템 24. 멤버 클래스는 되도록 static으로 만들라
- 비정적 멤버 클래스는 어댑터를 정의할 때 자주 쓰인다.
  - 즉, 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용하는 것
```
public class MySet<E> extends AbstractSet<E> {
  @Override public Iterator<E> iterator() {
    return new MyIterator();
  }
  private class MyIterator implemets Iterator<E> {
    ...
  }
```
