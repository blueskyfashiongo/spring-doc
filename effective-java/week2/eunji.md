# 📌 인상 깊었던 내용
### equals는 일반 규약을 지켜 재정의하라
- 다음에서 열거한 상황 중 하나에 해당한다면 재정의하지 않는 것이 최선이다.
  - 각 인스턴스가 본질적으로 고유하다
  - 인스턴스의 '논리적 동치성'을 검사할 일이 없다
  - 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다
  - 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.
 ```java
  @Override public boolean equals(Object o) {
    throw new AssertionError(); // 호출 금지!
  }
 ```
- 재정의해야할 때는 언제인가?
  - 논리적 동치성을 확인해야 할 때
  - 값을 비교할 수 있고 Map의 키와 Set의 원소로 사용할 수 있게 된다
- 값 클래스라고 해도 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장한다면 재정의하지 않아도 된다.


### Comparable을 구현할지 고려하라
- Comparable을 구현한 객체들의 배열은 다음처럼 손쉽게 정렬할 수 있다.
- Comparable을 구현하여 이 인터페이스를 활용하는 수많은 제네릭 알고리즘과 컬렉션의 힘을 누릴 수 있다.
- 사실상 자바 라이브러리의 모든 값 클래스와 열거타입이 Comparable을 구현했다.
- 알파벳, 숫자, 연대 같이 순서가 명확한 값 클래스를 작성한다면 반드시 Comparable 인터페이스를 구현하자.
- **compareTo 메서드로 수행한 동치성 테스트의 결과가 equals와 같아야 한다.**

# 📌 이해가 가지 않았던 내용
- 

# 📌 논의해보고 싶었던 내용
### equals는 일반 규약을 지켜 재정의하라
- Autovalue 프레임워크가 lombok의 @EqualsAndHashCode와 같은것일까..?

### toString을 항상 재정의하라
- 디버깅을 위한 용도인가? 언제 재정의하면 좋을까..(모든 객체?) 재정의하면 문제는 없을까?

### clone 재정의는 주의해서 진행하라
- cloneable 은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스. 언제 사용하는가?
