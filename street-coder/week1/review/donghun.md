# 📌 인상 깊었던 내용
> 사실, 여러분 코드의 품질을 걱정하는 것은 바로 동료들이다. 그들은 여러분의 코드가 제대로 동작하며, 이해하기 쉽고, 유지보수가 가능하기를 원한다. 여러분이 코드를 저장소에 올린 후에는 이제 모든 사람의 코드가 되기 떄문에 여러분은 그들에게 빚진 셈이 된다. 팀에서는 각 사람의 처리량보다 팀의 처리량이 더 중요하다. 만약 여러분이 나쁜 코드를 쓰고 있다면 여러분은 동료들의 속도를 늦추고 있는 것이다. 여러분의 ‘저질 코드’가 팀을 해치고, 느려진 팀은 제품을 해치고, 출시괴지 않은 제품은 결국 여러분의 경력에 도움이 되지 않는다. => 고용주는 주어진 시간에 얼마나 많은 것을 해줄 수 있느냐에만 관심이 있다.(딜레마)

> 마찬가지로 어떤 기능을 개발하는 데 걸리는 시간을 추정하는 등의 알 수 없는 매개변수가 속한 문제라면, 이미 알고 있는 정보를 기준으로 근사 범위를 좁힐 수 있다. 아무리 복잡해 보이는 것도 비교적 다루기 쉽고 덜 복잡한 것으로 나눌 수 있고, 결국은 이것들도 더 단순한 것으로 나눌 수 있다.

> 웹 개발자는 일반적으로 웹 내부의 네트워크 프로토콜이 어떻게 동작하는지 모른다. 특정 기술의 세부사항이 페이지 로딩 속도를 늦출 수 있다는 것을 모르기 때문에, 이러한 지연을 참고 사는 법을 배운다.

> 도구를 맹목적으로 사용하면 나중에 더 많은 문제가 발생할 수 있다. 새롭게 배워야 할 도메인 지식과 도구에 내재된 버그 때문에 속도가 더 늦어질 수 있다.

> 알고리즘을 변경하는 대신 타입을 제한하여 양수를 요구하는 식으로 수정.

> start + end 값의 오버플로우 가능성

> 생성자를 통한 입력값 유효성 검증

> 코드가 멈추지 않았어도 개선하자.

> 함수는 여러 일을 처리하지만, 결국 작업 하나만 수행해야 한다. 해당하는 작업의 이름을 따서 명명해야 한다. 함수 이름에 'and'나 'or'를 사용해야 한다고 느낀다면 함수 이름을 잘못 정했거나, 함수에 너무 많은 책임을 부여한 것이다.

> 예외적인 경우를 if안에 두고, 우리가 원하는 행복한 경로를 블록 밖에 놓도록 노력하라

# 📌 이해가 가지 않았던 내용

> 과거 사람들은 자기 차를 수리할 수 있었다. 이제 거의 모든 것이 오픈 소스이지만, 새로운 기술의 복잡성이 커졌기 때문에, 1990년대 바이너리 파일을 역설계한 코드보다 현재의 기술이 더 모호하다.

> 절대적으로 필요한 경우가 아니라면 스스로 상태를 바꾸도록 놔둬서는 안된다. 이 상태는 아무것도 아닌게 아니라 모든 악의 근원이다. 앱의 상태 변수가 적을수록 문제도 줄어든다. (44)

# 📌 논의해보고 싶었던 내용

> 연결 리스트의 사용성, 읽다보니 작은 오버헤드를 제외하고는 대부분의 지점에서 성능이 좋아보임.

> 빚을 지지마라. => 목표한 일정을 맞추기 위해서는 타협할 수 밖에 없는 구조. (불가피한 영역이 아닐까?)