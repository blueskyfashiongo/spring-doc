## 📌 인상 깊었던 내용
> 스택 오버플로 역사상 가장 유명한 질문은 " 왜 정렬되지 않은 배열을 처리하는 것보다 정렬된 배열을 처리하는 것이 더 빠를까?" 이다.
> 실행 시간을 최적화하기 위해 CPU는 실행 코드보다 선제적으로 움직여 필요하기 전에 미리 준비한다.
> 이럴 때 CPU가 사용하는 기술을 **분기 예측(branch prediction)** 이라고 한다.
>
> 📕 p.244 7장

### 🥸: 정렬된 배열은 CPU가 순서와 분기를 올바르게 예측할 수 있기 때문에 성능이 더 우수하다. 

> 불일치를 수용하라. 데이터베이스는 잠금, 트랜잭션, 원자 카운터, 트랜잭션 로그, 페이지 체크섬, 스냅샷 등과 같이 불일치를 방지하는 수많은 기능을 제공한다.
> 은행, 원자로, 중매 앱과 같이 잘못된 데이터를 가져와서는 절대 안 되는 시스템을 위해 설계되었기 때문이다.
> 성능과 확장성이 크게 향상된다면 견딜 수 있는 수준의 비신뢰성이 있다. NoSQL은 외래 키나 트랜잭션과 같이 전통적인 관계형 데이터베이스 시스템에서 추구하는 어떤 일관성을 무시하고
> 그 대가로 성능, 확장성, 은닉성을 얻겠다는 철학에서 나온 것이다.
>
> 📕 p.272 8장

### 🥸: NoSQL을 사용하면서 전통적인 데이터베이스 시스템에서 추구하는 바를 추구하고자 했었는데, 성능과 신뢰성은 트레이드 오프인 것 같다.

> I/O 작업이 없다면 비동기도 필요 없음을 의미한다.
>
> 📕 p.283 8장

## 📌 이해가 가지 않았던 내용
> 프로그래밍에서 가장 오해 받는 개념 중 하나는 비동기 I/O이다. 작업을 별도의 코어에서 실행하기 때문에 모든 종류의 작업을 떠 빠르게 수행하기 위한 병렬화 모델인 멀티스레딩과 혼동하는 경우가 많다.
> 비동기 I/O는 I/O 부하가 높은 작업만을 위한 병렬화 모델이며 단일 코어에서 작동할 수 있다. 멀티스레딩과 비동기 I/O는 서로 다른 목적을 위해 활용되며 함께 사용할 수도 있다.
> I/O는 자연스럽게 비동기적이다. 하드웨어에 I/O 작업이 할당되면 하드웨어가 그 작업을 실행하는 동안 CPU는 다른 작업을 계속 처리할 수 있으며, I/O 작업이 완료될 때 다시 그 결과를 확인할 수 있다.
> 이러한 메커니즘이 비동기 I/O의 기초가 된다.
>
> 📕 p.252 7장

> 추가적인 작업 없이 코드에 자연스러운 병렬화를 제공하는 데 있다. 스레드를 추가로 만들 필요도 없다. 실용적이며 확장 가능하다.

### 🥸: 기존처럼 사용하면 된다는 얘기일까?


## 📌 논의해보고 싶었던 내용

> 캐싱을 위해 설계되지 않은 데이터 구조는 사용하지 마라. 보통 오래된 데이터를 제거하거나 만료하는 메커니즘이 없기 때문에 메모리 누수의 원인이 되고, 결국에는 충돌하게 된다. 캐싱을 위해 설계된 것을 사용하라.
> 데이터베이스는 훌륭하고 영구적인 캐시가 될 수도 있다. 캐시 만료 시간이 무한대인 것을 두려워하지 마라. 이 우주가 끝나기 전에 캐시가 제거되거나 애플리케이션 재시작이 이뤄질 것이다.
>
> 📕 p.256 7장

### 🥸: 캐시 만료 시간이 무한대라면 왜 캐시를 사용하는가?
